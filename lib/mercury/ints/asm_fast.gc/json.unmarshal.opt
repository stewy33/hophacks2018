:- module (json.unmarshal).
:- use_module array, array2d, assoc_list, bag, bimap, bitmap, bool, builtin, calendar, char, cord, digraph, float, int, integer, io, list, map, maybe, mutvar, pair, pqueue, private_builtin, queue, rational, rbtree, require, set_bbbtree, set_ctree234, set_ordlist, set_tree234, set_unordlist, stream, string, type_desc, unit, univ, version_array, (json.char_buffer), (json.json_lexer), (json.json_parser), (json.marshal), (json.pointer), (json.string_reader), (json.unmarshal), (json.writer), (string.builder).
:- type json.unmarshal.check_row_result
	--->	crr_all_empty 
	;	crr_non_empty(((json.unmarshal).crr_ne_row_no) :: int, ((json.unmarshal).crr_ne_length) :: int)
	;	crr_bad_type(((json.unmarshal).crr_bt_row_no) :: int, ((json.unmarshal).crr_bd_value) :: json.value).
:- func (json.unmarshal).do_pair_from_json(string, string, json.value) = maybe.maybe_error(pair.pair(A_1, B_2), string) <= (json.from_json(A_1), json.from_json(B_2)).
:- mode (json.unmarshal).do_pair_from_json((builtin.in), (builtin.in), (builtin.in)) = (builtin.out) is det.
(json.unmarshal).pair_from_json(Value_3) = HeadVar__2_2 :-
    HeadVar__2_2 = (json.unmarshal).do_pair_from_json(V_4, V_5, Value_3),
    V_4 = "fst" : string,
    V_5 = "snd" : string.
